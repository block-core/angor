@page "/recover/{ProjectId}"

@using Angor.Shared
@using Angor.Client.Storage
@using Angor.Shared.Models
@using Angor.Shared.ProtocolNew
@using Angor.Shared.Services
@using Angor.Shared.Utilities
@using Blockcore.Consensus.TransactionInfo
@using Blockcore.NBitcoin
@using Blockcore.NBitcoin.DataEncoders
@using Angor.Client.Models

@inject IClientStorage Storage;
@inject ICacheStorage CacheStorage;
@inject IIndexerService IndexerService
@inject INetworkConfiguration NetworkConfiguration
@inject IDerivationOperations DerivationOperations
@inject IWalletOperations WalletOperations
@inject IInvestorTransactionActions InvestorTransactionActions
@inject ILogger<Recover> Logger;

@inherits BaseComponent

@if (!HasWallet)
{
    NavigationManager.NavigateTo($"/wallet");
    return;
}

<div class="container my-4">
    <h1>Recover funds</h1>
    <NotificationComponent @ref="NotificationComponent" />

    <p style="margin-bottom: 20px;">
        Project ID: <span id="transactionID">@ProjectId</span>
    </p>

    <p style="margin-bottom: 20px;">
        Transaction ID: <span id="transactionID">@_stageInfo.Trxid</span> | 
        <a href="@_explorerLink" target="_blank" style="margin-left: 10px;">View on explorer</a>
    </p>
    
    <p>Total funds to recover = @_stageInfo.TotalSpendable @Network.CoinTicker</p>
    
    @if (_trxNotFound)
    {
        <p class="alert alert-danger">Transaction was not found it may still be confirming</p>
    }

    @if (_firstTimeRefreshSpinner && _refreshSpinner)
    {
        <div class="d-flex justify-content-center">
            <div class="loader"></div>
        </div>
    }
    else
    {
        <div class="d-flex justify-content-between">
            <div>
                @if (!_refreshSpinner)
                {
                    @if (_stageInfo.CanRelease)
                    {
                        <p>Total funds in penalty = @_stageInfo.TotalInPenalty @Network.CoinTicker</p>
                    }

                    @if (_stageInfo.CanRecover && !_stageInfo.EndOfProject)
                    {
                        <button class="btn btn-primary me-2" @onclick="PrepareToRecoverCoins" disabled="@_prepareToRecoverCoinsModalSpinner">
                            @if (_prepareToRecoverCoinsModalSpinner)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>Recover Funds...</span>
                            }
                            else
                            {
                                <span>Recover Funds</span>
                            }
                        </button>
                    }

                    @if (_stageInfo.CanRelease)
                    {
                        <button class="btn btn-secondary me-2" @onclick="PrepareToReleaseCoins" disabled="@_prepareToReleaseCoinsModalSpinner">
                            @if (_prepareToReleaseCoinsModalSpinner)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>Release Funds...</span>
                            }
                            else
                            {
                                <span>Release Funds</span>
                            }
                        </button>
                    }

                    @if (_stageInfo.EndOfProject && _stageInfo.TotalSpendable > 0)
                    {
                        <button class="btn btn-primary" @onclick="PrepareEndOfProjectCoins" disabled="@_prepareEndOfProjectCoinsModalSpinner">
                            @if (_prepareEndOfProjectCoinsModalSpinner)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>End of project...</span>
                            }
                            else
                            {
                                <span>End of project</span>
                            }
                        </button>
                    }
                }
            </div>

            <div>
                <button class="btn btn-primary" @onclick="Scan" disabled="@_refreshSpinner">
                    @if (_refreshSpinner)
                    {
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        <span>Refresh...</span>
                    }
                    else
                    {
                        <span>Refresh</span>
                    }
                </button>
            </div>
        </div>
    }
    
    <br/>
    <br/>

    <table class="table">
        <thead>
            <tr>
                <th>Stage </th>
                <th>Amount</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var item in _stageInfo.Items)
            {
                <tr>
                    <td>@(item.StageIndex + 1)</td>
                    <td>@item.Amount @Network.CoinTicker</td>
                    <td>
                        @if (item.IsSpent)
                        {
                            <span class="text-primary">@item.SpentTo</span>
                        }
                        else
                        {
                            <span class="text-success">Not Spent</span>
                        }
                    </td>
                </tr>
            }
        </tbody>
    </table>

    @if (_showRecoveryModal)
    {
        <div class="modal fade show d-block" tabindex="-1" style="background: rgba(0, 0, 0, 0.5)">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Recovery Confirmation</h5>
                        <button type="button" class="btn-close" @onclick="() => _showRecoveryModal = false" disabled="@_prepareToRecoverCoinsConfirmSpinner"></button>
                    </div>
                    <div class="modal-body modal-body-scroll">

                        <p class="mb-1">The number of stages to be recovered is @_stageInfo.Items.Count(s => !s.IsSpent) </p>

                        <p class="mb-1">The amount to be recovered in to a penalty = @_stageInfo.Items.Where(s=> !s.IsSpent).Sum(s=> s.Amount) @Network.CoinTicker</p>

                        <p class="mb-1">The penalty duration is @_project.ProjectInfo.PenaltyDays days </p>
                        
                        <hr>

                        <div class="mb-3">
                            <label for="feeRange" class="form-label">Feerate for @_feeData.SelectedFeeEstimation.Confirmations blocks is @_feeData.SelectedFeeEstimation.FeeRate sats</label>
                            <input type="range" class="form-range" id="feeRange" @bind="_feeData.FeePosition" @oninput="RecoveryFeeRangeChanged" min="@_feeData.FeeMin" max="@_feeData.FeeMax">
                        </div>

                        <hr>

                        <p class="mt-3">Are you sure you want to recover these funds?</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="() => _showRecoveryModal = false" disabled="@_prepareToRecoverCoinsConfirmSpinner">Cancel</button>
                        <button type="button" class="btn btn-primary" @onclick="RecoverCoins" disabled="@_prepareToRecoverCoinsConfirmSpinner">
                            @if (_prepareToRecoverCoinsConfirmSpinner)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>Confirm...</span>
                            }
                            else
                            {
                                <span>Confirm</span>
                            }
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
    
    @if (_showRecoveryReleaseModal)
    {
        <div class="modal fade show d-block" tabindex="-1" style="background: rgba(0, 0, 0, 0.5)">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Release Recovery Confirmation</h5>
                        <button type="button" class="btn-close" @onclick="() => _showRecoveryReleaseModal = false" disabled="@_prepareToReleaseCoinsConfirmSpinner"></button>
                    </div>
                    <div class="modal-body modal-body-scroll">

                        <p class="mb-1">The amount to be released from the penalty = @Money.Satoshis(_releaseRecoveryTransaction.Outputs.Sum(s=> s.Value)).ToUnit(MoneyUnit.BTC) @Network.CoinTicker</p>

                        <p class="mb-1">Send to @_releaseRecoveryTransaction.Outputs[0].ScriptPubKey.GetDestinationAddress(NetworkConfiguration.GetNetwork()) </p>

                        <hr>

                        <div class="mb-3">
                            <label for="feeRange" class="form-label">Feerate for @_feeData.SelectedFeeEstimation.Confirmations blocks is @_feeData.SelectedFeeEstimation.FeeRate sats</label>
                            <input type="range" class="form-range" id="feeRange" @bind="_feeData.FeePosition" @oninput="ReleaseFeeRangeChanged" min="@_feeData.FeeMin" max="@_feeData.FeeMax">
                        </div>

                        <hr>

                        <p class="mt-3">Are you sure you want to release these funds from the penalty?</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="() => _showRecoveryReleaseModal = false" disabled="@_prepareToReleaseCoinsConfirmSpinner">Cancel</button>
                        <button type="button" class="btn btn-primary" @onclick="ReleaseCoins" disabled="@_prepareToReleaseCoinsConfirmSpinner">
                            @if (_prepareToReleaseCoinsConfirmSpinner)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>Confirm...</span>
                            }
                            else
                            {
                                <span>Confirm</span>
                            }
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
    
    @if (_showEndOfProjectModal)
    {
        <div class="modal fade show d-block" tabindex="-1" style="background: rgba(0, 0, 0, 0.5)">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">End Of project Confirmation</h5>
                        <button type="button" class="btn-close" @onclick="() => _showEndOfProjectModal = false" disabled="@_prepareEndOfProjectCoinsConfirmSpinner"></button>
                    </div>
                    <div class="modal-body modal-body-scroll">

                        <p class="mb-1">The amount to claim back after project ended = @Money.Satoshis(_endOfProjectTransaction.Outputs.Sum(s=> s.Value)).ToUnit(MoneyUnit.BTC) @Network.CoinTicker</p>

                        <p class="mb-1">Send to @_endOfProjectTransaction.Outputs[0].ScriptPubKey.GetDestinationAddress(NetworkConfiguration.GetNetwork()) </p>

                        <hr>

                        <div class="mb-3">
                            <label for="feeRange" class="form-label">Feerate for @_feeData.SelectedFeeEstimation.Confirmations blocks is @_feeData.SelectedFeeEstimation.FeeRate sats</label>
                            <input type="range" class="form-range" id="feeRange" @bind="_feeData.FeePosition" @oninput="EndOfProjectFeeRangeChanged" min="@_feeData.FeeMin" max="@_feeData.FeeMax">
                        </div>

                        <hr>

                        <p class="mt-3">Are you sure you want to claim these funds?</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="() => _showEndOfProjectModal = false" disabled="@_prepareEndOfProjectCoinsConfirmSpinner">Cancel</button>
                        <button type="button" class="btn btn-primary" @onclick="EndOfProjectCoins" disabled="@_prepareEndOfProjectCoinsConfirmSpinner">
                            @if (_prepareEndOfProjectCoinsConfirmSpinner)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>Confirm...</span>
                            }
                            else
                            {
                                <span>Confirm</span>
                            }

                        </button>
                    </div>
                </div>
            </div>
        </div>
    }

</div>

@code {
    [Parameter]
    public string ProjectId { get; set; }
    private InvestorProject _project;

    private bool _showRecoveryModal = false;
    private bool _showRecoveryReleaseModal = false;
    private bool _showEndOfProjectModal = false;

    private bool _refreshSpinner = false;
    private bool _firstTimeRefreshSpinner = false;
    private bool _prepareToRecoverCoinsModalSpinner = false;
    private bool _prepareToRecoverCoinsConfirmSpinner = false;

    private bool _prepareToReleaseCoinsModalSpinner = false;
    private bool _prepareToReleaseCoinsConfirmSpinner = false;

    private bool _prepareEndOfProjectCoinsModalSpinner = false;
    private bool _prepareEndOfProjectCoinsConfirmSpinner = false;

    private Transaction? _investmentTransaction; 
    private Transaction? _unsignedRecoveryTransaction;
    private Transaction? _recoveryTransaction;
    private Transaction? _releaseRecoveryTransaction;
    private Transaction? _endOfProjectTransaction;

    StageData _stageInfo = new();
    string _explorerLink;

    private FeeData _feeData = new();

    private bool _trxNotFound = false;
    public class StageData
    {
        public string Trxid;

        public QueryTransaction? TransactionInfo;
        public decimal TotalSpendable;
        public decimal TotalInPenalty;
        public bool CanRecover;
        public bool CanRelease;
        public bool EndOfProject;

        public List<StageDataTrx> Items = new ();
    }

    public class StageDataTrx
    {
        public int StageIndex;

        public int Outputindex;
        public string OutputAddress;
        public decimal Amount;
        public bool IsSpent;
        public string SpentTo;

        public ProjectScriptType ProjectScriptType;
    } 

    protected override async Task OnInitializedAsync()
    {
        _project = Storage.GetInvestmentProjects().First(p => p.ProjectInfo.ProjectIdentifier == ProjectId);

        _firstTimeRefreshSpinner = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (HasWallet)
            {
                await Scan();
            }
        }
    }

    private async Task Scan()
    {
        _refreshSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            await FindInvestments();

            await CheckSpentFund();
        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _refreshSpinner = false;
            _firstTimeRefreshSpinner = false;
        }

        StateHasChanged();
        await Task.Delay(10);
    }

    private async Task FindInvestments()
    {
        if (_stageInfo.TransactionInfo != null)
        {
            // we already fetched the trx info
            return;
        }

        var trxs = await IndexerService.GetInvestmentsAsync(_project.ProjectInfo.ProjectIdentifier);

        var trx = trxs.FirstOrDefault(f => f.TransactionId == _project.TransactionId);

        if (trx == null)
        {
            _explorerLink = NetworkConfiguration.GetExplorerUrl().Url + $"/transaction/{_project.TransactionId}";
            _trxNotFound = true;
            return;
        }

        _trxNotFound = false;

        if (_investmentTransaction == null)
        {
            var trxHex = await IndexerService.GetTransactionHexByIdAsync(_project.TransactionId);
            _investmentTransaction = Network.CreateTransaction(trxHex);
        }

        var trxInfo = await IndexerService.GetTransactionInfoByIdAsync(trx.TransactionId);

        _stageInfo.Trxid = trx.TransactionId;
        _stageInfo.TransactionInfo = trxInfo;
        _lastCheck = DateTime.UtcNow;

        _explorerLink = NetworkConfiguration.GetExplorerUrl().Url + $"/transaction/{trx.TransactionId}";

        _stageInfo.Items.Clear();

        int stageIndex = 0;
        foreach (var stageInfo in _project.ProjectInfo.Stages)
        {
            var output = trxInfo.Outputs.First(f => f.Index == stageIndex + 2);

            var insert = new StageDataTrx
            {
                OutputAddress = output.Address,
                Outputindex = stageIndex + 2,
                Amount = Money.Satoshis(output.Balance).ToUnit(MoneyUnit.BTC),
                StageIndex = stageIndex,
                IsSpent = false,

            };

            _stageInfo.Items.Add(insert);

            stageIndex++;
        }
    }

    DateTime _lastCheck = DateTime.UtcNow;
    private async Task CheckSpentFund()
    {
        if (_stageInfo.TransactionInfo == null)
        {
            return;
        }

        if ((DateTime.UtcNow - _lastCheck).Minutes > 1)
        {
            var trxInfo = await IndexerService.GetTransactionInfoByIdAsync(_stageInfo.TransactionInfo.TransactionId);
            _stageInfo.TransactionInfo = trxInfo;
            _lastCheck = DateTime.UtcNow;
        }
        else
        {
            await Task.Delay(500); // fake
        }

        var unconfirmedOutbound = CacheStorage.GetUnconfirmedOutboundFunds();
        bool modified = false;

        foreach (var infoOutput in _stageInfo.TransactionInfo.Outputs)
        {
            if (!string.IsNullOrEmpty(infoOutput.SpentInTransaction))
            {
                modified |= LinqExtension.Remove(unconfirmedOutbound, new Outpoint(_stageInfo.TransactionInfo.TransactionId, infoOutput.Index));
            }
        }

        if (modified)
        {
            CacheStorage.SetUnconfirmedOutboundFunds(unconfirmedOutbound);
        }

        var penaltyExpieryDate = Utils.UnixTimeToDateTime(_stageInfo.TransactionInfo.Timestamp).AddDays(_project.ProjectInfo.PenaltyDays);

        foreach (var item in _stageInfo.Items)
        {
            if (LinqExtension.Contains(unconfirmedOutbound, new Outpoint(_stageInfo.Trxid, item.Outputindex)))
            {
                item.IsSpent = true;
                item.SpentTo = "pending confirmations";
                item.ProjectScriptType = new ProjectScriptType { ScriptType = ProjectScriptTypeEnum.Unknown };

                continue;
            }

            var output = _stageInfo.TransactionInfo.Outputs.ElementAt(item.Outputindex);

            if (!string.IsNullOrEmpty(output.SpentInTransaction))
            {
                item.IsSpent = true;

                if (output.SpentInTransaction == _project.RecoveryTransactionId)
                {
                    if (!string.IsNullOrEmpty(_project.RecoveryReleaseTransactionId))
                    {
                        item.SpentTo = "Recovered after penalty";
                        item.ProjectScriptType = new ProjectScriptType { ScriptType = ProjectScriptTypeEnum.Unknown };
                    }
                    else
                    {
                        item.ProjectScriptType = new ProjectScriptType { ScriptType = ProjectScriptTypeEnum.InvestorWithPenalty };
                        var days = (penaltyExpieryDate - DateTime.Now).TotalDays;
                        item.SpentTo = days > 0 ? $"Penalty, released in {days.ToString("0.0")} days" : "Penalty can be released";
                    }
                }
                else
                {
                    // try to resolve the destination
                    var spentInTransaction = await IndexerService.GetTransactionInfoByIdAsync(output.SpentInTransaction);

                    var input = spentInTransaction?.Inputs.FirstOrDefault(input => input.InputTransactionId == _stageInfo.Trxid && input.InputIndex == item.Outputindex);

                    if (input != null && _investmentTransaction != null)
                    {
                        item.ProjectScriptType = InvestorTransactionActions.DiscoverUsedScript(_project.ProjectInfo, _investmentTransaction, item.StageIndex, input.WitScript);

                        switch (item.ProjectScriptType.ScriptType)
                        {
                            case ProjectScriptTypeEnum.Founder:
                                {
                                    item.SpentTo = "Spent by founder";
                                    break;
                                }
                            case ProjectScriptTypeEnum.InvestorWithPenalty:
                                {
                                    var days = (penaltyExpieryDate - DateTime.Now).TotalDays;
                                    item.SpentTo = days > 0 ? $"Penalty, released in {days.ToString("0.0")} days" : "Penalty can be released";
                                    break;
                                }
                            case ProjectScriptTypeEnum.EndOfProject:
                            case ProjectScriptTypeEnum.InvestorNoPenalty:
                                {
                                    item.SpentTo = $"Spent by investor";
                                    break;
                                }
                        }
                    }
                }
            }
        }

        _stageInfo.CanRecover = _stageInfo.Items.Any(a => a.IsSpent == false);
        _stageInfo.TotalSpendable = _stageInfo.Items.Where(a => !a.IsSpent).Sum(a => a.Amount);
        _stageInfo.CanRelease = (_stageInfo.Items.Any(a => a.ProjectScriptType?.ScriptType == ProjectScriptTypeEnum.InvestorWithPenalty) && DateTime.UtcNow > penaltyExpieryDate);
        _stageInfo.TotalInPenalty = _stageInfo.Items.Where(t => t.ProjectScriptType?.ScriptType == ProjectScriptTypeEnum.InvestorWithPenalty).Sum(t => t.Amount);
        _stageInfo.EndOfProject = _project.ProjectInfo.ExpiryDate < DateTime.Now;
    }

    private void AddTransactionToPending(Transaction transaction)
    {
        var accountInfo = Storage.GetAccountInfo(Network.Name);
        var unconfirmedInbound = CacheStorage.GetUnconfirmedInboundFunds();
        var unconfirmedOutbound = CacheStorage.GetUnconfirmedOutboundFunds();

        unconfirmedInbound.AddRange(WalletOperations.UpdateAccountUnconfirmedInfoWithSpentTransaction(accountInfo, transaction));
        unconfirmedOutbound.AddRange(transaction.Inputs.Select(_ => new Outpoint(_.PrevOut.Hash.ToString(), (int)_.PrevOut.N)));

        Storage.SetAccountInfo(Network.Name,accountInfo);
        CacheStorage.SetUnconfirmedInboundFunds(unconfirmedInbound);
        CacheStorage.SetUnconfirmedOutboundFunds(unconfirmedOutbound);
    }

    private async Task PrepareToRecoverCoins()
    {
        _prepareToRecoverCoinsModalSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            var fetchFees = await WalletOperations.GetFeeEstimationAsync();
            _feeData.FeeEstimations.Fees.Clear();
            _feeData.FeeEstimations.Fees.AddRange(fetchFees);
            _feeData.SelectedFeeEstimation = _feeData.FeeEstimations.Fees.First();

            var accountInfo = Storage.GetAccountInfo(Network.Name);
            var walletWords = WalletStorage.GetWallet().WalletWords;

            var investorPrivateKey = DerivationOperations.DeriveInvestorPrivateKey(walletWords, _project.ProjectInfo.FounderKey);

            _unsignedRecoveryTransaction = InvestorTransactionActions.AddSignaturesToRecoverSeederFundsTransaction(_project.ProjectInfo, _investmentTransaction, _project.SignaturesInfo, Encoders.Hex.EncodeData(investorPrivateKey.ToBytes()));

            // remove outputs that have been spent
            List<TxOut> removeTxout = new();
            List<TxIn> removeTxin = new();
            foreach (var item in _stageInfo.Items)
            {
                if (item.IsSpent)
                {
                    removeTxout.Add(_unsignedRecoveryTransaction.Outputs[item.StageIndex]);
                    removeTxin.Add(_unsignedRecoveryTransaction.Inputs[item.StageIndex]);
                }
            }

            foreach (var txOut in removeTxout) _unsignedRecoveryTransaction.Outputs.Remove(txOut);
            foreach (var txIn in removeTxin) _unsignedRecoveryTransaction.Inputs.Remove(txIn);

            // add fee to the recovery trx
            _recoveryTransaction = WalletOperations.AddFeeAndSignTransaction(accountInfo.GetNextChangeReceiveAddress(), _unsignedRecoveryTransaction, walletWords, accountInfo, _feeData.SelectedFeeEstimation);

            Logger.LogInformation($"recoveryTransaction={_recoveryTransaction.GetHash().ToString()}");

            _showRecoveryModal = true;
        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _prepareToRecoverCoinsModalSpinner = false;
        }
    }

    private void RecoveryFeeRangeChanged(ChangeEventArgs e)
    {
        var selected = e.Value?.ToString();

        if (selected != null)
        {
            if (int.TryParse(selected, out int res))
            {
                if (res <= _feeData.FeeEstimations.Fees.Count)
                {
                    _feeData.SelectedFeeEstimation = _feeData.FeeEstimations.Fees.OrderBy(fee => fee.Confirmations).ToList()[res - 1];

                    var accountInfo = Storage.GetAccountInfo(Network.Name);

                    _recoveryTransaction = WalletOperations.AddFeeAndSignTransaction(accountInfo.GetNextChangeReceiveAddress(), _unsignedRecoveryTransaction, WalletStorage.GetWallet().WalletWords, accountInfo, _feeData.SelectedFeeEstimation);

                    StateHasChanged();
                }
            }
        }
    }

    private async Task RecoverCoins()
    {
        _prepareToRecoverCoinsConfirmSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            _showRecoveryModal = false;

            Storage.UpdateInvestmentProject(_project);

            var response = await WalletOperations.PublishTransactionAsync(Network, _recoveryTransaction);

            if (!response.Success)
            {
                NotificationComponent.ShowErrorMessage(response.Message);
                return;
            }

            _project.RecoveryTransactionId = _recoveryTransaction.GetHash().ToString();
            _project.AmountInRecovery = _recoveryTransaction.TotalOut;

            Storage.UpdateInvestmentProject(_project);

            AddTransactionToPending(_recoveryTransaction);

            NotificationComponent.ShowNotificationMessage("Done", 1);

        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _prepareToRecoverCoinsConfirmSpinner = false;
        }
    }

    private async Task PrepareToReleaseCoins()
    {
        _prepareToReleaseCoinsModalSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            var fetchFees = await WalletOperations.GetFeeEstimationAsync();
            _feeData.FeeEstimations.Fees.Clear();
            _feeData.FeeEstimations.Fees.AddRange(fetchFees);
            _feeData.SelectedFeeEstimation = _feeData.FeeEstimations.Fees.First();

            var accountInfo = Storage.GetAccountInfo(Network.Name);

            var investorPrivateKey = DerivationOperations.DeriveInvestorPrivateKey(WalletStorage.GetWallet().WalletWords, _project.ProjectInfo.FounderKey);

            if (_recoveryTransaction == null)
            {
                var trxHex = await IndexerService.GetTransactionHexByIdAsync(_project.RecoveryTransactionId);
                _recoveryTransaction = Network.CreateTransaction(trxHex);
            }

            _releaseRecoveryTransaction = InvestorTransactionActions.BuildAndSignRecoverReleaseFundsTransaction(_project.ProjectInfo, _investmentTransaction, _recoveryTransaction,
                accountInfo.GetNextChangeReceiveAddress(), _feeData.SelectedFeeEstimation, Encoders.Hex.EncodeData(investorPrivateKey.ToBytes()));

            Logger.LogInformation($"recoveryReleaseTransactionId={_releaseRecoveryTransaction.GetHash().ToString()}");

            _showRecoveryReleaseModal = true;
        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _prepareToReleaseCoinsModalSpinner = false;
        }
    }

    private void ReleaseFeeRangeChanged(ChangeEventArgs e)
    {
        var selected = e.Value?.ToString();

        if (selected != null)
        {
            if (int.TryParse(selected, out int res))
            {
                if (res <= _feeData.FeeEstimations.Fees.Count)
                {
                    _feeData.SelectedFeeEstimation = _feeData.FeeEstimations.Fees.OrderBy(fee => fee.Confirmations).ToList()[res - 1];

                    var accountInfo = Storage.GetAccountInfo(Network.Name);

                    var investorPrivateKey = DerivationOperations.DeriveInvestorPrivateKey(WalletStorage.GetWallet().WalletWords, _project.ProjectInfo.FounderKey);

                    _releaseRecoveryTransaction = InvestorTransactionActions.BuildAndSignRecoverReleaseFundsTransaction(_project.ProjectInfo, _investmentTransaction, _recoveryTransaction,
                        accountInfo.GetNextChangeReceiveAddress(), _feeData.SelectedFeeEstimation, Encoders.Hex.EncodeData(investorPrivateKey.ToBytes()));

                    StateHasChanged();
                }
            }
        }
    }

    private async Task ReleaseCoins()
    {
        _prepareToReleaseCoinsConfirmSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            _showRecoveryReleaseModal = false;

            Storage.UpdateInvestmentProject(_project);

            var response = await WalletOperations.PublishTransactionAsync(Network, _releaseRecoveryTransaction);

            if (!response.Success)
            {
                NotificationComponent.ShowErrorMessage(response.Message);
                return;
            }

            _project.RecoveryReleaseTransactionId = _releaseRecoveryTransaction.GetHash().ToString();
            Storage.UpdateInvestmentProject(_project);

            AddTransactionToPending(_releaseRecoveryTransaction);

            NotificationComponent.ShowNotificationMessage("Done", 1);

        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _prepareToReleaseCoinsConfirmSpinner = false;
        }
    }

    private async Task PrepareEndOfProjectCoins()
    {
        _prepareEndOfProjectCoinsModalSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            var fetchFees = await WalletOperations.GetFeeEstimationAsync();
            _feeData.FeeEstimations.Fees.Clear();
            _feeData.FeeEstimations.Fees.AddRange(fetchFees);
            _feeData.SelectedFeeEstimation = _feeData.FeeEstimations.Fees.First();

            var accountInfo = Storage.GetAccountInfo(Network.Name);

            var investorPrivateKey = DerivationOperations.DeriveInvestorPrivateKey(WalletStorage.GetWallet().WalletWords, _project.ProjectInfo.FounderKey);

            var fromStage = _stageInfo.Items.First(f => f.IsSpent == false);

            _endOfProjectTransaction = InvestorTransactionActions.RecoverEndOfProjectFunds(_investmentTransaction.ToHex(Network.Consensus.ConsensusFactory), _project.ProjectInfo, fromStage.StageIndex,
                accountInfo.GetNextChangeReceiveAddress(), Encoders.Hex.EncodeData(investorPrivateKey.ToBytes()), _feeData.SelectedFeeEstimation);

            Logger.LogInformation($"EndOfProjectTransactionId={_endOfProjectTransaction.GetHash().ToString()}");

            _showEndOfProjectModal = true;
        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _prepareEndOfProjectCoinsModalSpinner = false;
        }
    }

    private void EndOfProjectFeeRangeChanged(ChangeEventArgs e)
    {
        var selected = e.Value?.ToString();

        if (selected != null)
        {
            if (int.TryParse(selected, out int res))
            {
                if (res <= _feeData.FeeEstimations.Fees.Count)
                {
                    _feeData.SelectedFeeEstimation = _feeData.FeeEstimations.Fees.OrderBy(fee => fee.Confirmations).ToList()[res - 1];

                    var accountInfo = Storage.GetAccountInfo(Network.Name);

                    var investorPrivateKey = DerivationOperations.DeriveInvestorPrivateKey(WalletStorage.GetWallet().WalletWords, _project.ProjectInfo.FounderKey);

                    var fromStage = _stageInfo.Items.First(f => f.IsSpent == false);

                    _endOfProjectTransaction = InvestorTransactionActions.RecoverEndOfProjectFunds(_investmentTransaction.ToHex(Network.Consensus.ConsensusFactory), _project.ProjectInfo, fromStage.StageIndex,
                        accountInfo.GetNextChangeReceiveAddress(), Encoders.Hex.EncodeData(investorPrivateKey.ToBytes()), _feeData.SelectedFeeEstimation);

                    StateHasChanged();
                }
            }
        }
    }

    private async Task EndOfProjectCoins()
    {
        _prepareEndOfProjectCoinsConfirmSpinner = true;
        StateHasChanged();
        await Task.Delay(10);

        try
        {
            _showEndOfProjectModal = false;

            Storage.UpdateInvestmentProject(_project);

            var response = await WalletOperations.PublishTransactionAsync(Network, _endOfProjectTransaction);

            if (!response.Success)
            {
                NotificationComponent.ShowErrorMessage(response.Message);
                return;
            }

            _project.EndOfProjectTransactionId = _endOfProjectTransaction.GetHash().ToString();
            Storage.UpdateInvestmentProject(_project);

            AddTransactionToPending(_endOfProjectTransaction);

            NotificationComponent.ShowNotificationMessage("Done", 1);
        }
        catch (Exception e)
        {
            Logger.LogError(e, e.Message);
            NotificationComponent.ShowErrorMessage(e.Message);
        }
        finally
        {
            _prepareEndOfProjectCoinsConfirmSpinner = false;
        }
    }
}
