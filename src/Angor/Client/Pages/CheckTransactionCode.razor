@page "/CheckTransactionCode"
@using Blockcore.Consensus.TransactionInfo
@using Angor.Client.Storage
@using Angor.Shared
@using Angor.Shared.Models
@using Angor.Shared.ProtocolNew
@using Blockcore.Consensus.ScriptInfo
@using Blockcore.NBitcoin
@using Blockcore.NBitcoin.BIP32
@using Blockcore.NBitcoin.Crypto
@using Blockcore.NBitcoin.DataEncoders
@using Microsoft.Extensions.Logging.Abstractions

<h3>CheckTransactionCode</h3>

@inject IWalletOperations WalletOperations; 
@inject INetworkConfiguration NetworkConfiguration;
@inject IClientStorage Storage;
@inject IWalletStorage WalletStorage;
@inject IHdOperations HdOperations;
@inject ISeederTransactionActions SeederTransactionActions;
@inject IFounderTransactionActions FounderTransactionActions;

<div class="container mt-4">
    <h1 class="mb-4">Dashboard</h1>
    
    <button type="button" class="btn btn-light" @onclick="CreateInvestmentTransaction">Load transaction</button>
    
</div>
        
@if (_transaction == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="card">
        <div class="card-body">
            <h5 class="card-title">@_transaction.GetHash()</h5>
            <h6>Inputs</h6>
            @foreach (var input in _transaction.Inputs)
            {
                <p class="card-text">From: @input.ScriptSig</p>
                <p class="card-text">Script: @input.WitScript</p>
            }
            <h6>Outputs</h6>
            @foreach (var output in _transaction.Outputs)
            {
                <p class="card-text">To: @output.ScriptPubKey</p>
                <p class="card-text">Amount: @output.Value BTC</p>
            }
        </div>
    </div>
}


@if (_founderTransaction == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="card">
        <div class="card-body">
            <h5 class="card-title">@_founderTransaction.GetHash()</h5>
            <h6>Inputs</h6>
            @foreach (var input in _founderTransaction.Inputs)
            {
                <p class="card-text">From: @input.ScriptSig</p>
                <p class="card-text">Script: @input.WitScript</p>
                <p class="card-text">Script: @(new Script(input.WitScript.ToScript().ToOps()[1].PushData).ToString())</p>
            }
            <h6>Outputs</h6>
            @foreach (var output in _founderTransaction.Outputs)
            {
                <p class="card-text">To: @output.ScriptPubKey</p>
                <p class="card-text">Amount: @output.Value BTC</p>
            }
        </div>
    </div>
}


@if (_recoveryTransaction == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="card">
        <div class="card-body">
            <h5 class="card-title">@_recoveryTransaction.GetHash()</h5>
            <h6>Inputs</h6>
            @foreach (var input in _recoveryTransaction.Inputs)
            {
                <p class="card-text">From: @input.ScriptSig</p>
                <p class="card-text">Script: @input.WitScript.ToScript().WitHash.ScriptPubKey.ToHex()</p>
                <p class="card-text">Script: @(input.WitScript.ToScript().ToString())</p>
            }
            <h6>Outputs</h6>
            @foreach (var output in _recoveryTransaction.Outputs)
            {
                <p class="card-text">To: @output.ScriptPubKey</p>
                <p class="card-text">Amount: @output.Value BTC</p>
            }
        </div>
    </div>
}

@code {

    Transaction _transaction;
    Transaction _founderTransaction;
    Transaction _recoveryTransaction;
    
    bool _showTransaction = false;
    private AccountInfo _localAccountInfo = new();

    private AccountInfo GetAccountInfoFromStorage()
    {
        var network = NetworkConfiguration.GetNetwork();
        return Storage.GetAccountInfo(network.Name);
    }

    private async Task CreateInvestmentTransaction()
    {
         DerivationOperations derivationOperations = new DerivationOperations(new HdOperations(), new NullLogger<DerivationOperations>(), NetworkConfiguration);
        
        var network = NetworkConfiguration.GetNetwork();
        _localAccountInfo = GetAccountInfoFromStorage();

        ExtPubKey accountExtPubKey = ExtPubKey.Parse(_localAccountInfo.ExtPubKey, network);
        var walletWords = WalletStorage.GetWallet().WalletWords;
        var extendedKey = HdOperations.GetExtendedKey(walletWords.Words, walletWords.Passphrase);

        var privateFounderKey = extendedKey.Derive(new KeyPath("m/84'/1'/0'/0/3")); //derive a different path for the founder keys testing
        
        var pubKey = HdOperations.GeneratePublicKey(accountExtPubKey, _localAccountInfo.LastFetchIndex + 1, false);

        string angorRootKey =
            "tpubD8JfN1evVWPoJmLgVg6Usq2HEW9tLqm6CyECAADnH5tyQosrL6NuhpL9X1cQCbSmndVrgLSGGdbRqLfUbE6cRqUbrHtDJgSyQEY2Uu7WwTL";
        
        //var angorPubKey = _hdOperations.GeneratePublicKey(accountExtPubKey, localAccountInfo.LastFetchIndex + 3, false);

        var secret = new Key();
        var testAddress = new Key();
        
        var context = new InvestorContext
        {
            ChangeAddress = _localAccountInfo.ChangeAddressesInfo.First().Address,
            InvestorKey = pubKey.ToHex(),
            ProjectInfo = new ProjectInfo
            {
                Stages = new List<Stage>
                {
                    new() { AmountToRelease = 1, ReleaseDate = DateTime.UtcNow.AddDays(1) },
                    new() { AmountToRelease = 1, ReleaseDate = DateTime.UtcNow.AddDays(2) },
                    new() { AmountToRelease = 1, ReleaseDate = DateTime.UtcNow.AddDays(3) }
                },
                ExpiryDate = DateTime.Now.AddDays(1),
                FounderKey = Encoders.Hex.EncodeData(privateFounderKey.Neuter().PubKey.ToBytes()),
                PenaltyDays = 100,
                StartDate = DateTime.Now,
                TargetAmount = 10,
                ProjectIdentifier = derivationOperations.DeriveAngorKey(Encoders.Hex.EncodeData(privateFounderKey.Neuter().PubKey.ToBytes()),angorRootKey),
                ProjectSeeders = new ProjectSeeders()
            }
        };

        _transaction = SeederTransactionActions.CreateInvestmentTransaction(context.ProjectInfo, pubKey.ToHex(), Hashes.Hash256(secret.ToBytes())
            , 1000000);

        context.TransactionHex = _transaction.ToHex();

        _recoveryTransaction = SeederTransactionActions.BuildRecoverSeederFundsTransaction(context.ProjectInfo, _transaction, context.ProjectInfo.PenaltyDays, testAddress.PubKey.ToHex());

        var signatures = FounderTransactionActions.SignInvestorRecoveryTransactions(context.ProjectInfo, context.TransactionHex, _recoveryTransaction, Encoders.Hex.EncodeData(privateFounderKey.PrivateKey.ToBytes()));

        var sendInfo = new SendInfo
        {
            ChangeAddress = pubKey.GetSegwitAddress(network).ToString(),
            SendAmount = 10,
            SendToAddress = privateFounderKey.Neuter().PubKey.GetSegwitAddress(network).ToString()
        };

        WalletOperations.CalculateTransactionFee(sendInfo, _localAccountInfo,  1000);

        var fee = await WalletOperations.GetFeeEstimationAsync();

        _recoveryTransaction = SeederTransactionActions.AddSignaturesToRecoverSeederFundsTransaction(context.ProjectInfo, _transaction, testAddress.PubKey.ToHex(), signatures, Encoders.Hex.EncodeData(privateFounderKey.PrivateKey.ToBytes()), 
            Encoders.Hex.EncodeData(secret.ToBytes()));

        _founderTransaction = FounderTransactionActions.SpendFounderStage(context.ProjectInfo, new List<string>(){ _transaction.ToHex()}, 1,
            testAddress.ScriptPubKey , privateFounderKey.PrivateKey.ToHex(network.Consensus.ConsensusFactory), fee.First());
        
        _transaction = WalletOperations.AddInputsAndSignTransaction(context.ChangeAddress, _transaction, walletWords, _localAccountInfo, fee.First());
        
        _showTransaction = true;
    }

}