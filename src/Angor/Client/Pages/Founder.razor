@page "/founder"
@using Angor.Client.Models
@using Angor.Client.Storage
@using Angor.Shared.Models
@using Angor.Shared.Services
@using Nostr.Client.Messages
@using Angor.Shared;
@using Blockcore.NBitcoin.DataEncoders;
@using DBreeze.Utils
@using Nostr.Client.Keys;

@inject NavigationManager NavigationManager
@inject IWalletStorage _walletStorage;
@inject IClientStorage storage;
@inject IRelayService RelayService;
@inject IIndexerService _IndexerService
@inject ISerializer serializer
@inject IDerivationOperations _derivationOperations
@inject ICacheStorage SessionStorage
@inject IEncryptionService _encryptionService

@inherits BaseComponent
<NotificationComponent @ref="notificationComponent"/>
<PasswordComponent @ref="passwordComponent"/>


@if (!hasWallet)
{
    NavigationManager.NavigateTo("/wallet");
    return;
}

<div class="row">
    <div class="card card-body">
        <div class="d-flex align-items-center justify-content-between">
            <div class="d-flex col-auto my-auto align-items-center">
                <span class="user-select-none">
                    <Icon IconName="founder" Height="42" Width="42"/>
                </span>
                <div class="h-100 ms-3">
                    <h5 class="mb-0 font-weight-bolder">
                        Founder
                    </h5>

                </div>
            </div>
            <div class="tooltip-container" data-bs-toggle="tooltip" title="@GetCreateButtonTooltip()">
                <button
                    class="btn btn-border"
                    @onclick="NavigateToCreateProject"
                    disabled="@(scanningForProjects || (founderProjects.Count >= 14) ? true : null)">                    <i>
                        <Icon IconName="add"></Icon>
                    </i>
                    <span class="nav-link-text ms-1">
                        @(scanningForProjects ? "Scanning..." : "Create Project")
                    </span>
                </button>
            </div>

        </div>
        <p class="mb-0 font-weight-normal text-sm mt-4">
            To create a new project or view your existing projects, an on-chain transaction and a Nostr DID are required.
        </p>
    </div>
</div>

@if (founderProjects.Count == 0)
{
    <div class="row mt-4">
        <div class="card card-body angor-alert-info pt-2 pb-2">
            <div class="d-flex align-items-center align-items-center">
                <span class="me-3 user-select-none">
                    <Icon IconName="info" Width="40" Height="40" Color="var(--angor-primary)"/>
                </span>
                <span class="text-white">No projects found.</span>
            </div>
        </div>
    </div>
}

@if (founderProjects.Count > 0)
{
    <div class="row row-cols-1 row-cols-sm-1 row-cols-md-2 row-cols-lg-3 project-wrapper" data-cy="project-grid">
        @foreach (var project in founderProjects)
        {
            <FounderProjectItem FounderProject="@project"></FounderProjectItem>
        }
    </div>
}

<button class="btn btn-primary" @onclick="CheckForInvestments">
    Check for Investments
</button>
<div class="row mt-4">
    @if (investmentMessages.Any())
    {
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Investment Notifications</h5>
                <ul>
                    @foreach (var message in investmentMessages)
                    {
                    <li>@message</li>
                    }
                </ul>
            </div>
        </div>
    </div>
    }
    else
    {
    <div class="col-12">
        <div class="alert alert-info">No new investments found.</div>
    </div>
    }
</div>

<div class="row">
    <div class="col">
        <div class="d-flex justify-content-center mt-4">
            <button class="btn btn-border my-3" @onclick="LookupProjectKeysOnIndexerAsync">
                <i class="@(scanningForProjects ? "rotate-icon" : "")">
                    <Icon IconName="refresh"></Icon>
                </i>
                <span class="nav-link-text ms-1">@(founderProjects.Count == 0 ? "Scan for founder projects" : "Rescan founder projects")</span>
            </button>
        </div>
    </div>
</div>

@code {
    private string founderKey;
    private string projectId;
    private List<FounderProject> founderProjects = new();
    private bool hasWallet;
    bool scanningForProjects;

    private string founderPrivateKey;
    private string founderPubKey;
    private List<string> investmentMessages = new();

    private NotificationComponent notificationComponent;


    protected override async Task OnInitializedAsync()
    {
        hasWallet = _walletStorage.HasWallet();

        if (hasWallet)
        {
            founderProjects = storage.GetFounderProjects().Where(_ => !string.IsNullOrEmpty(_.CreationTransactionId)).ToList();
        }
    }

    private async Task LookupProjectKeysOnIndexerAsync()
    {
        scanningForProjects = true;

        var keys = _walletStorage.GetFounderKeys();
        var founderProjectsToLookup = new Dictionary<string, ProjectIndexerData>();

        foreach (var key in keys.Keys)
        {
            if (founderProjects.Any(_ => _.ProjectInfo.ProjectIdentifier == key.ProjectIdentifier))
                continue;

            var indexerProject = await _IndexerService.GetProjectByIdAsync(key.ProjectIdentifier);

            if (indexerProject != null) //TODO we need to talk about supporting projects that are created with gaps
                founderProjectsToLookup.Add(key.NostrPubKey, indexerProject);
        }

        if (!founderProjectsToLookup.Any())
        {
            scanningForProjects = false;
            return;
        }

        RelayService.RequestProjectCreateEventsByPubKey(
            e =>
            {
                switch (e)
                {
                    case { Kind: NostrKind.Metadata }:
                        var nostrMetadata = serializer.Deserialize<ProjectMetadata>(e.Content);
                        var existingProject = founderProjects.FirstOrDefault(_ => _.ProjectInfo.NostrPubKey == e.Pubkey);

                        if (existingProject != null)
                        {
                            existingProject.Metadata ??= nostrMetadata;
                        }
                        else
                        {
                            var founderProject = CreateFounderProject(founderProjectsToLookup, e);
                            founderProject.Metadata = nostrMetadata;
                            founderProjects.Add(founderProject);
                        }

                        break;

                    case { Kind: NostrKind.ApplicationSpecificData }:

                        if (e.Id != founderProjectsToLookup[e.Pubkey].NostrEventId)
                            return;

                        var projectInfo = serializer.Deserialize<ProjectInfo>(e.Content);
                        var project = founderProjects.FirstOrDefault(_ => _.ProjectInfo.NostrPubKey == e.Pubkey);

                        if (project != null)
                        {
                            if (!string.IsNullOrEmpty(project.ProjectInfo.ProjectIdentifier))
                                return;

                            project.ProjectInfo = projectInfo;
                        }
                        else
                        {
                            project ??= CreateFounderProject(founderProjectsToLookup, e, projectInfo);
                            founderProjects.Add(project);
                        }

                        break;
                }
            },
            () =>
            {
                scanningForProjects = false;

                // Merge or update projects in storage
                foreach (var project in founderProjects)
                {
                    var existing = storage.GetFounderProjects().FirstOrDefault(p => p.ProjectInfo.ProjectIdentifier == project.ProjectInfo.ProjectIdentifier);
                    if (existing == null)
                    {
                        storage.AddFounderProject(new[] { project });
                    }
                    else
                    {
                        storage.UpdateFounderProject(project);
                    }
                }

                StateHasChanged();
            },
            founderProjectsToLookup.Keys.ToArray());
    }

    private FounderProject CreateFounderProject(Dictionary<string, ProjectIndexerData> founderProjectsToLookup,
        NostrEvent e, ProjectInfo? projectInfo = null)
    {
        var keys = _walletStorage.GetFounderKeys();
        var projectIndex = keys.Keys.First(x => x.NostrPubKey == e.Pubkey).Index; //we throw if not found
        var trxId = founderProjectsToLookup[e.Pubkey].TrxId;

        return new FounderProject
        {
            ProjectInfo = projectInfo ?? new ProjectInfo { NostrPubKey = e.Pubkey },
            ProjectIndex = projectIndex,
            CreationTransactionId = trxId,
            NostrProfileCreated = true,
            ProjectInfoEventId = founderProjectsToLookup[e.Pubkey].NostrEventId
        };
    }

    private async Task NavigateToCreateProject()
    {
        // perform a rescan before creating a project (to update the keys)
        await LookupProjectKeysOnIndexerAsync();

        NavigationManager.NavigateTo("/create");
    }

    private string GetCreateButtonTooltip()
    {
        if (founderProjects.Count >= 15)
            return "You have reached the maximum number of projects. Please manage your existing projects.";
        if (scanningForProjects)
            return "Scanning in progress...";
        return "Create a new project.";
    }

    private async Task CheckForInvestments()
    {
        try
        {
            // Ensure user provides the wallet password
            if (!passwordComponent.HasPassword())
            {
                passwordComponent.ShowPassword(async () => await InitializeKeysAndScanInvestments());
            }
            else
            {
                await InitializeKeysAndScanInvestments();
            }
        }
        catch (Exception ex)
        {
            notificationComponent.ShowErrorMessage($"Error: {ex.Message}", ex);
        }
    }

    private async Task InitializeKeysAndScanInvestments()
    {
        try
        {
            // Retrieve wallet seed words
            var words = await passwordComponent.GetWalletAsync();
            if (words == null)
            {
                notificationComponent.ShowErrorMessage("Unable to retrieve wallet seed words.");
                return;
            }

            // Derive the founder's private key
            var founderProject = storage.GetFounderProjects().FirstOrDefault();
            if (founderProject == null)
            {
                notificationComponent.ShowNotificationMessage("No founder projects found.");
                return;
            }

            var derivedPrivateKey = _derivationOperations.DeriveFounderPrivateKey(words, founderProject.ProjectIndex);
            if (derivedPrivateKey == null)
            {
                notificationComponent.ShowErrorMessage("Failed to derive the founder's private key.");
                return;
            }

            founderPrivateKey = derivedPrivateKey.GetWif(network).ToString();
            founderPubKey = derivedPrivateKey.PubKey.ToHex();

            // Scan for investments using the derived keys
            await ScanForInvestments(founderPubKey);
        }
        catch (Exception ex)
        {
            notificationComponent.ShowErrorMessage($"Error initializing keys or scanning for investments: {ex.Message}", ex);
        }
    }

    private async Task ScanForInvestments(string pubKeyHex)
    {
        try
        {
            investmentMessages.Clear();

            await RelayService.LookupDirectMessagesForPubKeyAsync(
                pubKeyHex,
                null,
                limit: 50,
                async message =>
                {
                    var decryptedMessage = await _encryptionService.DecryptNostrContentAsync(
                        founderPrivateKey,
                        pubKeyHex,
                        message.Content);

                    investmentMessages.Add(decryptedMessage);
                    StateHasChanged();
                },
                pubKeyHex);

            if (!investmentMessages.Any())
            {
                investmentMessages.Add("No investments found.");
            }
        }
        catch (Exception ex)
        {
            notificationComponent.ShowErrorMessage($"Error scanning for investments: {ex.Message}", ex);
        }
    }

}